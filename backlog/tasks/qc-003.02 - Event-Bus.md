---
id: QC-003.02
title: Event Bus Infrastructure
status: Done
assignee: []
created_date: '2026-01-29'
labels:
  - application
  - foundation
  - P0
dependencies: []
parent_task_id: QC-003
milestone: M-001
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Implement the foundational Event Bus for domain event pub/sub. This is the backbone of the Functional DDD architecture, enabling decoupled communication between bounded contexts and reactive UI updates via Signal Bridges.
<!-- SECTION:DESCRIPTION:END -->

## Rationale

The Event Bus is critical infrastructure that:
- Enables domain events to flow from Controllers to Signal Bridges
- Supports cross-context communication (e.g., Coding → Analysis)
- Allows Policies to react to events from any context
- Must be thread-safe for background operations

## Acceptance Criteria
<!-- AC:BEGIN -->

### Core Pub/Sub
- [x] #1 `subscribe(event_type, handler)` - subscribe by event type string
- [x] #2 `subscribe_type(event_class, handler)` - subscribe by event class
- [x] #3 `subscribe_all(handler)` - subscribe to all events
- [x] #4 `unsubscribe(event_type, handler)` - remove subscription
- [x] #5 `publish(event)` - publish event to all matching subscribers

### Thread Safety
- [x] #6 Thread-safe publish from background threads
- [x] #7 Handlers invoked synchronously (desktop app model)
- [x] #8 Lock-free read path for performance

### Subscription Management
- [x] #9 Returns subscription handle for easy cleanup
- [x] #10 `clear()` - remove all subscriptions
- [x] #11 `clear_for_handler(handler)` - remove all subscriptions for a handler
- [ ] #12 Weak reference option to prevent memory leaks (deferred)

### Event Type Resolution
- [x] #13 Supports string event types (e.g., "coding.code_created")
- [x] #14 Supports class-based event types (e.g., CodeCreated)
- [x] #15 Auto-derives string type from class if not specified

### Debugging Support
- [x] #16 Optional event history (last N events)
- [x] #17 Subscription count introspection
- [x] #18 Event type listing

<!-- AC:END -->

## Implementation Notes

**Simple synchronous implementation for desktop app:**
- No async/await needed - PyQt6 handles threading
- Signal Bridges handle thread-safe UI updates
- Keep it simple: dict of handlers, publish iterates and calls

**Event type convention:**
```python
# String format: "{context}.{event_name}"
"coding.code_created"
"sources.source_imported"
"cases.case_created"
```

## File Structure

```
src/
├── application/
│   ├── event_bus.py          # EventBus implementation
│   └── __init__.py           # Export EventBus
```

## Interface

```python
class EventBus:
    def subscribe(self, event_type: str, handler: Callable[[Any], None]) -> Subscription
    def subscribe_type(self, event_class: type, handler: Callable) -> Subscription
    def subscribe_all(self, handler: Callable[[Any], None]) -> Subscription
    def unsubscribe(self, event_type: str, handler: Callable) -> None
    def publish(self, event: DomainEvent) -> None
    def clear(self) -> None

@dataclass
class Subscription:
    """Handle for managing a subscription."""
    def cancel(self) -> None: ...
```

## Downstream Dependencies

This task unblocks:
- QC-003.01 - Base Signal Bridge (integration testing)
- QC-006 - Coding Application (controller event publishing)
- All Signal Bridge implementations

## Testing Strategy

- [x] Unit test subscribe/publish flow
- [x] Unit test type-based subscription
- [x] Unit test subscription cleanup
- [x] Thread safety test (publish from background)
- [ ] Integration test with BaseSignalBridge (deferred to QC-006.04)
