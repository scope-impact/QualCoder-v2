---
id: QC-022.03
title: Merge Conflict Types
status: To Do
assignee: []
created_date: '2026-01-29 16:43'
labels:
  - domain
  - collaboration
  - P1
dependencies: []
parent_task_id: QC-022
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Value objects: MergeConflict (overlapping segments), ResolutionStrategy (keep_source/keep_target/keep_both), MergeResult.
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
### MergeConflict Value Object (frozen dataclass)
- [ ] #1 `MergeConflict`: conflict_id, conflict_type (NAME|SEGMENT|ATTRIBUTE), source_item, target_item, description
- [ ] #2 `ConflictType` enum: NAME (duplicate names), SEGMENT (overlapping codings), ATTRIBUTE (conflicting values)

### ResolutionStrategy Enum
- [ ] #3 `ResolutionStrategy`: KEEP_SOURCE, KEEP_TARGET, KEEP_BOTH, RENAME, MERGE
- [ ] #4 Each strategy has clear semantic: which version to preserve

### MergeResolution Value Object (frozen dataclass)
- [ ] #5 `MergeResolution`: conflict_id, strategy, new_name (optional for RENAME)
- [ ] #6 Immutable - records how conflict was resolved

### MergeResult Value Object (frozen dataclass)
- [ ] #7 `MergeResult`: merge_id, conflicts_resolved, segments_reassigned, success (bool)
- [ ] #8 Summary of merge operation

### MergePlan Value Object
- [ ] #9 `MergePlan`: source_code, target_code, conflicts (List), resolutions (List)
- [ ] #10 Preview before execution - no side effects

### Pure Functions
- [ ] #11 `detect_conflicts(source_code, target_code, segments) -> List[MergeConflict]`
- [ ] #12 `apply_resolution(conflict, resolution) -> Result[MergedItem, Error]`
- [ ] #13 `preview_merge(plan: MergePlan) -> MergePreview` - shows what would change
<!-- AC:END -->
