---
id: QC-003.01
title: Base Signal Bridge Infrastructure
status: To Do
assignee: []
created_date: '2026-01-29'
labels:
  - application
  - foundation
  - P0
dependencies: []
parent_task_id: QC-003
milestone: M-001
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Create the foundational Signal Bridge infrastructure that all context-specific bridges (Coding, Source, Case, Agent, Collaboration) will inherit from. This establishes the thread-safe pattern for bridging domain events to Qt signals.
<!-- SECTION:DESCRIPTION:END -->

## Rationale

All 5 context-specific Signal Bridges share:
- Singleton pattern
- Thread-safe emission via `QMetaObject.invokeMethod`
- Event Bus subscription
- Event → Payload conversion

Extracting this to a base class reduces duplication and ensures consistent behavior.

## Acceptance Criteria
<!-- AC:BEGIN -->

### BaseSignalBridge Class (QObject)
- [ ] #1 `BaseSignalBridge(QObject)` - abstract base class for all signal bridges
- [ ] #2 Generic singleton pattern via `cls.instance()` class method
- [ ] #3 `_instances: dict[type, BaseSignalBridge]` class-level registry

### Thread-Safe Emission
- [ ] #4 `_emit_threadsafe(signal, payload)` - handles cross-thread emission
- [ ] #5 Uses `QMetaObject.invokeMethod` with `Qt.QueuedConnection`
- [ ] #6 Detects if already on main thread → emit directly
- [ ] #7 `_is_main_thread() -> bool` helper method

### Event Bus Integration
- [ ] #8 `__init__(event_bus: EventBus)` - accepts event bus dependency
- [ ] #9 `_subscribe_events()` - abstract method, subclasses define subscriptions
- [ ] #10 `_unsubscribe_events()` - cleanup on destruction
- [ ] #11 `_on_domain_event(event: DomainEvent)` - dispatcher, calls converter + emitter

### Converter Registry Pattern
- [ ] #12 `EventConverter` protocol: `convert(event: DomainEvent) -> PayloadDTO`
- [ ] #13 `_converters: dict[str, EventConverter]` - maps event_type → converter
- [ ] #14 `register_converter(event_type: str, converter: EventConverter)` method
- [ ] #15 Subclasses register their converters in `_subscribe_events()`

### Signal Mapping
- [ ] #16 `_signal_map: dict[str, pyqtSignal]` - maps event_type → Qt signal
- [ ] #17 `register_signal(event_type: str, signal: pyqtSignal)` method
- [ ] #18 Auto-wiring: event arrives → convert → emit mapped signal

### Activity Feed Integration
- [ ] #19 `activity_logged = pyqtSignal(object)` - common signal on base class
- [ ] #20 `_emit_activity(event, payload)` - formats and emits to activity feed
- [ ] #21 `ActivityItem` dataclass with timestamp, session_id, description, status

### Lifecycle Management
- [ ] #22 `start()` - begin listening to events
- [ ] #23 `stop()` - stop listening, cleanup subscriptions
- [ ] #24 Context manager support: `__enter__` / `__exit__`

### Payload DTOs
- [ ] #25 `SignalPayload` base class (frozen dataclass)
- [ ] #26 Common fields: `timestamp`, `session_id`, `is_ai_action`, `event_type`
- [ ] #27 `ActivityItem` dataclass for activity feed
- [ ] #28 `ActivityStatus` enum: COMPLETED, PENDING, QUEUED, REJECTED, FAILED

<!-- AC:END -->

## Implementation

```
src/
├── application/
│   └── signal_bridge/
│       ├── __init__.py
│       ├── base.py              # BaseSignalBridge class
│       ├── protocols.py         # EventConverter protocol
│       ├── payloads.py          # SignalPayload, ActivityItem
│       └── thread_utils.py      # Thread detection helpers
```

## Usage Example

```python
from application.signal_bridge.base import BaseSignalBridge
from PyQt6.QtCore import pyqtSignal

class CodingSignalBridge(BaseSignalBridge):
    # Context-specific signals
    code_created = pyqtSignal(object)
    segment_coded = pyqtSignal(object)

    def _subscribe_events(self):
        # Register converters
        self.register_converter("coding.code_created", CodeCreatedConverter())
        self.register_converter("coding.segment_coded", SegmentCodedConverter())

        # Map events to signals
        self.register_signal("coding.code_created", self.code_created)
        self.register_signal("coding.segment_coded", self.segment_coded)

        # Subscribe to event bus
        self._event_bus.subscribe("coding.*", self._on_domain_event)
```

## Downstream Tasks

This task unblocks and simplifies:
- QC-006.04 - Signal Bridge (Coding)
- QC-010.06 - Source Signal Bridge
- QC-014.05 - Case Signal Bridge
- QC-020.06 - Agent Signal Bridge
- QC-024.05 - Collaboration Signal Bridge

## Testing Strategy

- [ ] Unit test thread-safe emission (mock Qt main thread)
- [ ] Unit test converter registry
- [ ] Unit test signal mapping
- [ ] Integration test with real EventBus
- [ ] Verify singleton behavior across imports
