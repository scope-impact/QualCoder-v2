---
id: QC-008.02
title: Speaker Entity
status: To Do
assignee: []
created_date: '2026-01-29 16:40'
labels:
  - domain
  - sources
  - P1
dependencies: []
parent_task_id: QC-008
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Speaker entity with name, color, position ranges. SpeakerFormat value object for pattern matching (Name:, [Name], {Name}). Supports transcript speaker extraction.
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
### Speaker Value Object (frozen dataclass)
- [ ] #1 `Speaker` value object: name (str), color (Color), occurrences (int)
- [ ] #2 Immutable - no identity, compared by value
- [ ] #3 Factory method: `Speaker.create(name, color=None)` - auto-assigns color if not provided

### SpeakerFormat Enum
- [ ] #4 `SpeakerFormat` enum: COLON ("Name:"), BRACKET ("[Name]"), BRACE ("{Name}"), AUTO (detect)
- [ ] #5 Each format has regex pattern: `pattern() -> str` method

### SpeakerMatch Value Object (frozen dataclass)
- [ ] #6 `SpeakerMatch` value object: speaker_name, format, positions (List[TextPosition])
- [ ] #7 Represents detected speaker occurrences in transcript

### Pure Functions (Derivers)
- [ ] #8 `detect_speakers(text: str, format: SpeakerFormat) -> List[SpeakerMatch]` - pure text analysis
- [ ] #9 `extract_speaker_name(match: re.Match, format: SpeakerFormat) -> str` - extracts name from regex match

### Invariants
- [ ] #10 `is_valid_speaker_name(name: str) -> bool` - non-empty, reasonable length
- [ ] #11 `is_speaker_unique(name: str, existing: List[Speaker]) -> bool` - no duplicates

### Integration with Coding Context
- [ ] #12 Speakers can be converted to Codes via `CreateSpeakerCodes` command
- [ ] #13 Speaker â†’ Code mapping preserves name and color
<!-- AC:END -->
